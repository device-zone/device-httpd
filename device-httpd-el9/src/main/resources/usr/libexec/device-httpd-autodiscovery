#!/bin/bash

#
# Apache httpd Server Autodiscovery
# =================================
#
# This script autogenerates any required httpd instances.

set -e
umask 0007


#
# Handle the cleanup
# ------------------
cleanup_before_exit () {
  if [ -d "${tmpdir}" ]; then
    rm -rf "${tmpdir}"
  fi
}
# be in a temporay workspace (this works on linux and macosx)
tmpdir=`mktemp -d 2>/dev/null || mktemp -d -t 'tmpdir'`
# trap catches the exit signal and runs the specified function
trap cleanup_before_exit EXIT
# be in our directory
cd "${tmpdir}"


#
# Create instance that does not yet exist
create_instance() {
  instance="${1}"

  cat > "device-${instance}.conf" <<- EOF
# Generated by $0 on `date`
# DO NOT MODIFY THIS FILE - it will be overwritten on server restart.
#

ServerRoot "/etc/httpd"

Listen 80

PidFile /run/httpd/httpd-device-${instance}.pid

User apache
Group apache

<Directory />
    AllowOverride none
    Require all denied
</Directory>

LoadModule authz_core_module modules/mod_authz_core.so
LoadModule systemd_module modules/mod_systemd.so
LoadModule unixd_module modules/mod_unixd.so

#
# DocumentRoot: The directory out of which you will serve your
# documents. By default, all requests are taken from this directory, but
# symbolic links and aliases may be used to point to other locations.
#
DocumentRoot "/var/www/html"

#
# Relax access to content within /var/www.
#
<Directory "/var/www">
    AllowOverride None
    # Allow open access:
    Require all granted
</Directory>

# Further relax access to the default document root:
<Directory "/var/www/html">
    #
    # Possible values for the Options directive are "None", "All",
    # or any combination of:
    #   Indexes Includes FollowSymLinks SymLinksifOwnerMatch ExecCGI MultiViews
    #
    # Note that "MultiViews" must be named *explicitly* --- "Options All"
    # doesn't give it to you.
    #
    # The Options directive is both complicated and important.  Please see
    # http://httpd.apache.org/docs/2.4/mod/core.html#options
    # for more information.
    #
    Options Indexes FollowSymLinks

    #
    # AllowOverride controls what directives may be placed in .htaccess files.
    # It can be "All", "None", or any combination of the keywords:
    #   Options FileInfo AuthConfig Limit
    #
    AllowOverride None

    #
    # Controls who can get stuff from this server.
    #
    Require all granted
</Directory>

#
# DirectoryIndex: sets the file that Apache will serve if a directory
# is requested.
#
<IfModule dir_module>
    DirectoryIndex index.html
</IfModule>

#
# The following lines prevent .htaccess and .htpasswd files from being 
# viewed by Web clients. 
#
<Files ".ht*">
    Require all denied
</Files>

#
# ErrorLog: The location of the error log file.
# If you do not specify an ErrorLog directive within a <VirtualHost>
# container, error messages relating to that virtual host will be
# logged here.  If you *do* define an error logfile for a <VirtualHost>
# container, that host's errors will be logged there and not here.
#
ErrorLog "logs/device-${instance}-error_log"

<IfModule mime_module>
    #
    # TypesConfig points to the file containing the list of mappings from
    # filename extension to MIME-type.
    #
    TypesConfig /etc/mime.types

    #
    # AddType allows you to add to or override the MIME configuration
    # file specified in TypesConfig for specific file types.
    #
    #AddType application/x-gzip .tgz
    #
    # AddEncoding allows you to have certain browsers uncompress
    # information on the fly. Note: Not all browsers support this.
    #
    #AddEncoding x-compress .Z
    #AddEncoding x-gzip .gz .tgz
    #
    # If the AddEncoding directives above are commented-out, then you
    # probably should define those extensions to indicate media types:
    #
    AddType application/x-compress .Z
    AddType application/x-gzip .gz .tgz

    #
    # AddHandler allows you to map certain file extensions to "handlers":
    # actions unrelated to filetype. These can be either built into the server
    # or added with the Action directive (see below)
    #
    # To use CGI scripts outside of ScriptAliased directories:
    # (You will also need to add "ExecCGI" to the "Options" directive.)
    #
    #AddHandler cgi-script .cgi

    # For type maps (negotiated resources):
    #AddHandler type-map var

    #
    # Filters allow you to process content before it is sent to the client.
    #
    # To parse .shtml files for server-side includes (SSI):
    # (You will also need to add "Includes" to the "Options" directive.)
    #
    AddType text/html .shtml
    AddOutputFilter INCLUDES .shtml
</IfModule>

#
# Specify a default charset for all content served; this enables
# interpretation of all content as UTF-8 by default.  To use the
# default browser choice (ISO-8859-1), or to allow the META tags
# in HTML content to override this choice, comment out this
# directive:
#
AddDefaultCharset UTF-8

<IfModule mime_magic_module>
    #
    # The mod_mime_magic module allows the server to use various hints from the
    # contents of the file itself to determine its type.  The MIMEMagicFile
    # directive tells the module where the hint definitions are located.
    #
    MIMEMagicFile conf/magic
</IfModule>

#
# EnableMMAP and EnableSendfile: On systems that support it,
# memory-mapping or the sendfile syscall may be used to deliver
# files.  This usually improves server performance, but must
# be turned off when serving from networked-mounted
# filesystems or if support for these functions is otherwise
# broken on your system.
# Defaults if commented: EnableMMAP On, EnableSendfile Off
#
#EnableMMAP off
EnableSendfile on

# Supplemental configuration
#
# Load config files in the "/etc/httpd/conf.d" directory, if any.
IncludeOptional conf.d/device-${instance}/*.conf


EOF

  install -m 640 "device-${instance}.conf" "/etc/httpd/conf/device-${instance}.conf"
  install -d 0750 "/etc/httpd/conf.d/device-${instance}"

}


#
# Remove existing instance
remove_instance() {
  instance="${1}"

  rm -f "/etc/httpd/conf/device-${instance}.conf"
  rm -rf "/etc/httpd/conf.d/device-${instance}"
}


#
# Per application? Run all scripts

run_scripts() {

  instance="${1}"
  line="${2}"

  logger -t "httpd-autodiscovery@${instance}" "running autodiscovery for httpd instance ${instance}..."

  find "$0.d" -type f -executable | sort | \
  while read x; do
    "$x" "${instance}" "${line}" < /dev/null || touch error;
  done

  if test ! -f "error"; then
    logger -t "httpd-autodiscovery@${instance}" "completed autodiscovery for httpd instance ${instance}."
  else
    logger -t "httpd-autodiscovery@${instance}" "failed autodiscovery for httpd instance ${instance}."
  fi

}


#
# Add/remove httpd instances

find /etc/device/services/www/instance/ -mindepth 1 -maxdepth 1 -type l | \
while read line; do

  target=$(readlink -f "$line")

  if test ! -f "$line/name.txt"; then
    continue;
  fi
  instance="$(head $line/name.txt)"

  # remove old instances
  if test -f "$line/removed"; then

    logger -t httpd-autodiscovery "removing httpd server instance ${instance}..."

    systemctl disable "httpd@device-${instance}"
    systemctl stop "httpd@device-${instance}"

    remove_instance "${instance}"
    logger -t httpd-autodiscovery "removed httpd server instance ${instance}."

    # remove folder
    rm -f "${target}"/*
    rmdir "${target}"
    rm -f "${line}"

  # add new instances
  elif test -f "$line/added"; then

    # instance already exist and we're told to add? none of our business, remove the device config for safety
    if test -d "/etc/httpd/device-${instance}"; then

      logger -t httpd-autodiscovery "'/etc/httpd/device-${instance}' already exists, ignoring '$line'"
      echo "Webserver ${instance} already exists" > ${line}/error

      continue;
    fi

    logger -t httpd-autodiscovery "creating httpd server instance ${instance}..."
    create_instance "${instance}"
    run_scripts "${instance}" "${line}"
    logger -t httpd-autodiscovery "created httpd server instance ${instance}."

    if test -f "$line/disabled.bin"; then

      systemctl disable "httpd@device-${instance}"
      systemctl stop "httpd@device-${instance}"

    else

      systemctl enable "httpd@device-${instance}"
      systemctl start "httpd@device-${instance}"

    fi

    rm -f "$line/added"

  # update instances
  elif test -f "$line/updated"; then

    instance="$(head $line/name.txt)"

    if test -f "$line/disabled.bin"; then

      systemctl disable "httpd@device-${instance}"
      systemctl stop "httpd@device-${instance}"

      run_scripts "${instance}" "${line}"

    else

      run_scripts "${instance}" "${line}"

      systemctl enable "httpd@device-${instance}"
      systemctl start "httpd@device-${instance}"

    fi

    rm -f "$line/updated"

  # something we depend on changed
  else

    instance="$(head $line/name.txt)"

    run_scripts "${instance}" "${line}"

    systemctl try-reload-or-restart "httpd@device-${instance}"

  fi

done


